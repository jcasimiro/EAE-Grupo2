# não dar erro.
cores <- c(
rgb(250/255, 251/255, 101/255),
rgb(232/255, 149/255, 112/255),
rgb(165/255, 164/255, 250/255),
"cyan",
"brown",
"green",
"red",
"blue",
"gray",
"coral",
"maroon"
)
# Recalcular o grau de cada nó existente
graus <- degree(g, mode = "all")
# Adicionar o novo nó (sempre branco)
g <- g + vertices(1)
# Colocar o nó adicionado como branco
cores[i] = "white"
# Remover as cores de nós não usados
n <- length(cores)-i
cores <- cores[-((length(cores)-n+1):length(cores))]
V(g)$color <- cores
# Calcular a probabilidade de conexão para cada nó existente
prob <- graus / sum(graus)
# Escolher m nós com base na probabilidade de conexão
nos_conectados <- sample(vcount(g) - 1, m, replace = FALSE, prob = prob)
# Conectar o novo nó aos nós escolhidos
arestas_novas <- c(sapply(nos_conectados, function(x) c(vcount(g), x)))
g <- g + edges(arestas_novas)
}
# Mostrar a rede
plot(g, vertex.size=10, vertex.label=NA, vertex.color=V(g)$color, asp=0)
# Carregar a biblioteca igraph
library(igraph)
# Parâmetros iniciais
n0 <- 3  # Número de nós iniciais
m <- 3   # Número de arestas que cada novo nó terá
n <- 4   # Número total de nós desejado na rede
# Criar uma rede inicial com n0 nós
g <- make_full_graph(n0)
# Crescer a rede adicionando um novo nó por vez
for(i in seq(n0 + 1, n)) {
# Inicializar o vetor de cores para os nós.
# Nota: As 11 cores permite ir até aos 11 nós, caso seja pretendido
# adicionar mais nós é preciso adicionar mais cores para o programa
# não dar erro.
cores <- c(
rgb(250/255, 251/255, 101/255),
rgb(232/255, 149/255, 112/255),
rgb(165/255, 164/255, 250/255),
"cyan",
"brown",
"green",
"red",
"blue",
"gray",
"coral",
"maroon"
)
# Recalcular o grau de cada nó existente
graus <- degree(g, mode = "all")
# Adicionar o novo nó (sempre branco)
g <- g + vertices(1)
# Colocar o nó adicionado como branco
cores[i] = "white"
# Remover as cores de nós não usados
n <- length(cores)-i
cores <- cores[-((length(cores)-n+1):length(cores))]
V(g)$color <- cores
# Calcular a probabilidade de conexão para cada nó existente
prob <- graus / sum(graus)
# Escolher m nós com base na probabilidade de conexão
nos_conectados <- sample(vcount(g) - 1, m, replace = FALSE, prob = prob)
# Conectar o novo nó aos nós escolhidos
arestas_novas <- c(sapply(nos_conectados, function(x) c(vcount(g), x)))
g <- g + edges(arestas_novas)
}
# Mostrar a rede
plot(g, vertex.size=5, vertex.label=NA, vertex.color=V(g)$color, asp=0)
# Carregar a biblioteca igraph
library(igraph)
# Parâmetros iniciais
n0 <- 3  # Número de nós iniciais
m <- 3   # Número de arestas que cada novo nó terá
n <- 5   # Número total de nós desejado na rede
# Criar uma rede inicial com n0 nós
g <- make_full_graph(n0)
# Crescer a rede adicionando um novo nó por vez
for(i in seq(n0 + 1, n)) {
# Inicializar o vetor de cores para os nós.
# Nota: As 11 cores permite ir até aos 11 nós, caso seja pretendido
# adicionar mais nós é preciso adicionar mais cores para o programa
# não dar erro.
cores <- c(
rgb(250/255, 251/255, 101/255),
rgb(232/255, 149/255, 112/255),
rgb(165/255, 164/255, 250/255),
rgb(197/255, 236/255, 250/255),
"brown",
"green",
"red",
"blue",
"gray",
"coral",
"maroon"
)
# Recalcular o grau de cada nó existente
graus <- degree(g, mode = "all")
# Adicionar o novo nó (sempre branco)
g <- g + vertices(1)
# Colocar o nó adicionado como branco
cores[i] = "white"
# Remover as cores de nós não usados
n <- length(cores)-i
cores <- cores[-((length(cores)-n+1):length(cores))]
V(g)$color <- cores
# Calcular a probabilidade de conexão para cada nó existente
prob <- graus / sum(graus)
# Escolher m nós com base na probabilidade de conexão
nos_conectados <- sample(vcount(g) - 1, m, replace = FALSE, prob = prob)
# Conectar o novo nó aos nós escolhidos
arestas_novas <- c(sapply(nos_conectados, function(x) c(vcount(g), x)))
g <- g + edges(arestas_novas)
}
# Mostrar a rede
plot(g, vertex.size=5, vertex.label=NA, vertex.color=V(g)$color, asp=0)
# Carregar a biblioteca igraph
library(igraph)
# Parâmetros iniciais
n0 <- 3  # Número de nós iniciais
m <- 3   # Número de arestas que cada novo nó terá
n <- 5   # Número total de nós desejado na rede
# Criar uma rede inicial com n0 nós
g <- make_full_graph(n0)
# Crescer a rede adicionando um novo nó por vez
for(i in seq(n0 + 1, n)) {
# Inicializar o vetor de cores para os nós.
# Nota: As 11 cores permite ir até aos 11 nós, caso seja pretendido
# adicionar mais nós é preciso adicionar mais cores para o programa
# não dar erro.
cores <- c(
rgb(250/255, 251/255, 101/255),
rgb(232/255, 149/255, 112/255),
rgb(165/255, 164/255, 250/255),
rgb(197/255, 236/255, 250/255),
rgb(82/255, 67/255, 23/255),
"green",
"red",
"blue",
"gray",
"coral",
"maroon"
)
# Recalcular o grau de cada nó existente
graus <- degree(g, mode = "all")
# Adicionar o novo nó (sempre branco)
g <- g + vertices(1)
# Colocar o nó adicionado como branco
cores[i] = "white"
# Remover as cores de nós não usados
n <- length(cores)-i
cores <- cores[-((length(cores)-n+1):length(cores))]
V(g)$color <- cores
# Calcular a probabilidade de conexão para cada nó existente
prob <- graus / sum(graus)
# Escolher m nós com base na probabilidade de conexão
nos_conectados <- sample(vcount(g) - 1, m, replace = FALSE, prob = prob)
# Conectar o novo nó aos nós escolhidos
arestas_novas <- c(sapply(nos_conectados, function(x) c(vcount(g), x)))
g <- g + edges(arestas_novas)
}
# Mostrar a rede
plot(g, vertex.size=5, vertex.label=NA, vertex.color=V(g)$color, asp=0)
# Carregar a biblioteca igraph
library(igraph)
# Parâmetros iniciais
n0 <- 3  # Número de nós iniciais
m <- 3   # Número de arestas que cada novo nó terá
n <- 6   # Número total de nós desejado na rede
# Criar uma rede inicial com n0 nós
g <- make_full_graph(n0)
# Crescer a rede adicionando um novo nó por vez
for(i in seq(n0 + 1, n)) {
# Inicializar o vetor de cores para os nós.
# Nota: As 11 cores permite ir até aos 11 nós, caso seja pretendido
# adicionar mais nós é preciso adicionar mais cores para o programa
# não dar erro.
cores <- c(
rgb(250/255, 251/255, 101/255),
rgb(232/255, 149/255, 112/255),
rgb(165/255, 164/255, 250/255),
rgb(197/255, 236/255, 250/255),
rgb(82/255, 67/255, 23/255),
rgb(203/255, 231/255, 104/255),
"red",
"blue",
"gray",
"coral",
"maroon"
)
# Recalcular o grau de cada nó existente
graus <- degree(g, mode = "all")
# Adicionar o novo nó (sempre branco)
g <- g + vertices(1)
# Colocar o nó adicionado como branco
cores[i] = "white"
# Remover as cores de nós não usados
n <- length(cores)-i
cores <- cores[-((length(cores)-n+1):length(cores))]
V(g)$color <- cores
# Calcular a probabilidade de conexão para cada nó existente
prob <- graus / sum(graus)
# Escolher m nós com base na probabilidade de conexão
nos_conectados <- sample(vcount(g) - 1, m, replace = FALSE, prob = prob)
# Conectar o novo nó aos nós escolhidos
arestas_novas <- c(sapply(nos_conectados, function(x) c(vcount(g), x)))
g <- g + edges(arestas_novas)
}
# Mostrar a rede
plot(g, vertex.size=5, vertex.label=NA, vertex.color=V(g)$color, asp=0)
# Carregar a biblioteca igraph
library(igraph)
# Parâmetros iniciais
n0 <- 3  # Número de nós iniciais
m <- 3   # Número de arestas que cada novo nó terá
n <- 6   # Número total de nós desejado na rede
# Criar uma rede inicial com n0 nós
g <- make_full_graph(n0)
# Crescer a rede adicionando um novo nó por vez
for(i in seq(n0 + 1, n)) {
# Inicializar o vetor de cores para os nós.
# Nota: As 11 cores permite ir até aos 11 nós, caso seja pretendido
# adicionar mais nós é preciso adicionar mais cores para o programa
# não dar erro.
cores <- c(
rgb(250/255, 251/255, 101/255),
rgb(232/255, 149/255, 112/255),
rgb(165/255, 164/255, 250/255),
rgb(197/255, 236/255, 250/255),
rgb(82/255, 67/255, 23/255),
rgb(203/255, 231/255, 104/255),
"red",
"blue",
"gray",
"coral",
"maroon"
)
# Recalcular o grau de cada nó existente
graus <- degree(g, mode = "all")
# Adicionar o novo nó (sempre branco)
g <- g + vertices(1)
# Colocar o nó adicionado como branco
cores[i] = "white"
# Remover as cores de nós não usados
n <- length(cores)-i
cores <- cores[-((length(cores)-n+1):length(cores))]
V(g)$color <- cores
# Calcular a probabilidade de conexão para cada nó existente
prob <- graus / sum(graus)
# Escolher m nós com base na probabilidade de conexão
nos_conectados <- sample(vcount(g) - 1, m, replace = FALSE, prob = prob)
# Conectar o novo nó aos nós escolhidos
arestas_novas <- c(sapply(nos_conectados, function(x) c(vcount(g), x)))
g <- g + edges(arestas_novas)
}
# Mostrar a rede
plot(g, vertex.size=5, vertex.label=NA, vertex.color=V(g)$color, asp=0)
# Carregar a biblioteca igraph
library(igraph)
# Parâmetros iniciais
n0 <- 3  # Número de nós iniciais
m <- 3   # Número de arestas que cada novo nó terá
n <- 6   # Número total de nós desejado na rede
# Criar uma rede inicial com n0 nós
g <- make_full_graph(n0)
# Crescer a rede adicionando um novo nó por vez
for(i in seq(n0 + 1, n)) {
# Inicializar o vetor de cores para os nós.
# Nota: As 11 cores permite ir até aos 11 nós, caso seja pretendido
# adicionar mais nós é preciso adicionar mais cores para o programa
# não dar erro.
cores <- c(
rgb(250/255, 251/255, 101/255),
rgb(232/255, 149/255, 112/255),
rgb(165/255, 164/255, 250/255),
rgb(197/255, 236/255, 250/255),
rgb(192/255, 155/255, 39/255),
rgb(203/255, 231/255, 104/255),
"red",
"blue",
"gray",
"coral",
"maroon"
)
# Recalcular o grau de cada nó existente
graus <- degree(g, mode = "all")
# Adicionar o novo nó (sempre branco)
g <- g + vertices(1)
# Colocar o nó adicionado como branco
cores[i] = "white"
# Remover as cores de nós não usados
n <- length(cores)-i
cores <- cores[-((length(cores)-n+1):length(cores))]
V(g)$color <- cores
# Calcular a probabilidade de conexão para cada nó existente
prob <- graus / sum(graus)
# Escolher m nós com base na probabilidade de conexão
nos_conectados <- sample(vcount(g) - 1, m, replace = FALSE, prob = prob)
# Conectar o novo nó aos nós escolhidos
arestas_novas <- c(sapply(nos_conectados, function(x) c(vcount(g), x)))
g <- g + edges(arestas_novas)
}
# Mostrar a rede
plot(g, vertex.size=5, vertex.label=NA, vertex.color=V(g)$color, asp=0)
# Carregar a biblioteca igraph
library(igraph)
# Parâmetros iniciais
n0 <- 3  # Número de nós iniciais
m <- 3   # Número de arestas que cada novo nó terá
n <- 7   # Número total de nós desejado na rede
# Criar uma rede inicial com n0 nós
g <- make_full_graph(n0)
# Crescer a rede adicionando um novo nó por vez
for(i in seq(n0 + 1, n)) {
# Inicializar o vetor de cores para os nós.
# Nota: As 11 cores permite ir até aos 11 nós, caso seja pretendido
# adicionar mais nós é preciso adicionar mais cores para o programa
# não dar erro.
cores <- c(
rgb(250/255, 251/255, 101/255),
rgb(232/255, 149/255, 112/255),
rgb(165/255, 164/255, 250/255),
rgb(197/255, 236/255, 250/255),
rgb(192/255, 155/255, 39/255),
rgb(203/255, 231/255, 104/255),
"red",
"blue",
"gray",
"coral",
"maroon"
)
# Recalcular o grau de cada nó existente
graus <- degree(g, mode = "all")
# Adicionar o novo nó (sempre branco)
g <- g + vertices(1)
# Colocar o nó adicionado como branco
cores[i] = "white"
# Remover as cores de nós não usados
n <- length(cores)-i
cores <- cores[-((length(cores)-n+1):length(cores))]
V(g)$color <- cores
# Calcular a probabilidade de conexão para cada nó existente
prob <- graus / sum(graus)
# Escolher m nós com base na probabilidade de conexão
nos_conectados <- sample(vcount(g) - 1, m, replace = FALSE, prob = prob)
# Conectar o novo nó aos nós escolhidos
arestas_novas <- c(sapply(nos_conectados, function(x) c(vcount(g), x)))
g <- g + edges(arestas_novas)
}
# Mostrar a rede
plot(g, vertex.size=5, vertex.label=NA, vertex.color=V(g)$color, asp=0)
install.packages(c("bslib", "callr", "dbplyr", "deldir", "digest", "fable", "feasts", "forecast", "future", "future.apply", "ggdist", "ggsci", "globals", "gmodels", "Hmisc", "htmltools", "httpuv", "igraph", "lattice", "lava", "lintr", "lme4", "pkgbuild", "processx", "ragg", "RcppArmadillo", "RcppEigen", "remotes", "rmarkdown", "rstudioapi", "sass", "shiny", "stinepack", "systemfonts", "tidyselect", "tinytex", "xfun"))
install.packages(c("Amelia", "brio", "explore", "fabletools", "fs", "ggfortify", "ggplot2", "gtable", "labelled", "lme4", "matrixStats", "openssl", "RcppArmadillo", "seriation", "styler", "survival", "testthat"))
# No menu do RStudio:
# selecione Session > Set Working Directory > Choose Directory...
if (!requireNamespace("plot.matrix", quietly = TRUE)) install.packages("plot.matrix")
if (!requireNamespace("dbscan", quietly = TRUE)) install.packages("dbscan")
if (!requireNamespace("ggplot2", quietly = TRUE)) install.packages("ggplot2")
if (!requireNamespace("rpart", quietly = TRUE)) install.packages("rpart")
if (!requireNamespace("rpart.plot", quietly = TRUE)) install.packages("rpart.plot")
if (!requireNamespace("caret", quietly = TRUE)) install.packages("caret")
if (!requireNamespace("stats", quietly = TRUE)) install.packages("stats")
if (!requireNamespace("pROC", quietly = TRUE)) install.packages("pROC")
library(plot.matrix)
library(dbscan)
library(ggplot2)
library(rpart)
library(rpart.plot)
library(caret)
library(stats)
library(pROC)
plotfigure <<- function(row,dataset)
{
X = NULL
if(!is.null(nrow(dataset)))
{
X = data.frame(matrix(dataset[row,2:785],nrow=28))
}
else
{
X = data.frame(matrix(dataset[row,2:785],nrow=28))
}
m1 = data.matrix(X)
plot(m1, cex=0.5)
}
#https://www.kaggle.com/datasets/crawford/emnist
#Read the zip codes dataset.
#Each line corresponds to a handwritten figure.
#The first column shows the corresponding symbol.
#The next 256 (16x16) columns correspond to the orange color of each píxel in the fig
dataset <<- read.csv("emnist-balanced-train.csv",sep=",",header = FALSE)
setwd("~/Projects/EAE-Grupo2")
# No menu do RStudio:
# selecione Session > Set Working Directory > Choose Directory...
if (!requireNamespace("plot.matrix", quietly = TRUE)) install.packages("plot.matrix")
if (!requireNamespace("dbscan", quietly = TRUE)) install.packages("dbscan")
if (!requireNamespace("ggplot2", quietly = TRUE)) install.packages("ggplot2")
if (!requireNamespace("rpart", quietly = TRUE)) install.packages("rpart")
if (!requireNamespace("rpart.plot", quietly = TRUE)) install.packages("rpart.plot")
if (!requireNamespace("caret", quietly = TRUE)) install.packages("caret")
if (!requireNamespace("stats", quietly = TRUE)) install.packages("stats")
if (!requireNamespace("pROC", quietly = TRUE)) install.packages("pROC")
library(plot.matrix)
library(dbscan)
library(ggplot2)
library(rpart)
library(rpart.plot)
library(caret)
library(stats)
library(pROC)
plotfigure <<- function(row,dataset)
{
X = NULL
if(!is.null(nrow(dataset)))
{
X = data.frame(matrix(dataset[row,2:785],nrow=28))
}
else
{
X = data.frame(matrix(dataset[row,2:785],nrow=28))
}
m1 = data.matrix(X)
plot(m1, cex=0.5)
}
#https://www.kaggle.com/datasets/crawford/emnist
#Read the zip codes dataset.
#Each line corresponds to a handwritten figure.
#The first column shows the corresponding symbol.
#The next 256 (16x16) columns correspond to the orange color of each píxel in the fig
dataset <<- read.csv("emnist-balanced-train.csv",sep=",",header = FALSE)
#Function that plots the figure
#corresponding to a specific dataset row
plotfigure(13,dataset)
plotfigure(4,dataset)
# Contar o número de elementos (linhas) no dataset
num_elementos_total <- nrow(dataset)
# Mostrar o número de elementos
print(paste("Número de elementos no dataset:", num_elementos_total))
# Filtar o dataset apenas para os caracteres do meu grupo
label_D <- 13
label_F <- 15
# Filtrar o dataset para conter apenas os registros de "D" e "F"
filtered_dataset <- dataset[dataset$V1 %in% c(label_D, label_F), ]
#criar modelo de árvore de decisão
modelo_arvore <- rpart(V1 ~ ., data = filtered_dataset, method = "class")
#mosrar árvore de decisão
rpart.plot(modelo_arvore, main="Árvore de Decisão - 'D' vs 'F'")
# checks the accuracy of the model
data_test <<- read.csv("emnist-balanced-test.csv",sep=",",header = FALSE)
# Filtrar o data_test para conter apenas os registros de "D" e "F"
filtered_data_test <- data_test[data_test$V1 %in% c(label_D, label_F), ]
# Efetuar a previsão
prediction_probs <- predict(modelo_arvore, newdata = filtered_data_test, type = "prob")[, as.character(label_D)]
# Gerar a curva ROC
roc_obj <- roc(filtered_data_test$V1, prediction_probs)
# Mostrar a curva ROC
plot(roc_obj)
# Encontrar o threshold ótimo usando o critério Youden
coords(roc_obj, "best", ret = "threshold", best.method = "youden")
# Definir o threshold de probabilidade
threshold <- 0.5 # Obtido da curva ROC e arredondado
# Fica mais bonito e dá o mesmo valor na matriz de confusão
# Converter probabilidades em previsões binárias com base no threshold
predicted_classes <- ifelse(prediction_probs > threshold, label_D, label_F)
# Criar a matriz de confusão
conf_matrix <- table(Predicted = predicted_classes, Actual = filtered_data_test$V1)
# Mostrar a matriz de confusão
conf_matrix_detailed <- confusionMatrix(as.factor(predicted_classes), as.factor(filtered_data_test$V1))
print(conf_matrix_detailed)
# 10 PIXEIS MAIS IMPORTANTES
# Identificar os 10 pixeis mais importantes
importancia <- as.data.frame(modelo_arvore$variable.importance)
names(importancia) <- c("Importância")
importancia <- importancia[order(-importancia$Importância), , drop = FALSE]
pixeis_mais_importantes <- head(importancia, 10)
print(pixeis_mais_importantes)
print(rownames(pixeis_mais_importantes))
# Extrair apenas os números dos nomes dos pixeis mais importantes e convertê-los para valores inteiros
nomes_pixeis_inteiros <- as.integer(gsub("V", "", rownames(pixeis_mais_importantes)))
# Mostrar os nomes dos pixeis mais importantes como valores inteiros
print(nomes_pixeis_inteiros)
# Mostrar BOXPLOT para os 10 pixeis
# Configuração do tamanho do gráfico e centralização
par(mfrow=c(1,1), mar=c(3,3,1,1))
# Loop para criar os boxplots para cada pixel mais importante
for (pixel in nomes_pixeis_inteiros) {
# Criar um vetor de rótulos correspondentes a cada linha no dataset
character_labels <- ifelse(filtered_dataset$V1 == label_D, "D", "F")
# Plot do boxplot
boxplot(as.matrix(filtered_dataset[, pixel]) ~ character_labels,
main=paste("Distribuição dos Valores dos Pixels para 'D' e 'F' (Pixel: V", pixel, ")"),
col=c("red", "blue"),
las=2,
xlab="Letras",
ylab="Intensidade dos pixeis",
#outline=FALSE
)
}
filtered_dataset_pca <- prcomp(filtered_dataset)
summary(filtered_dataset_pca)
